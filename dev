#!/bin/sh
# Prefer Homebrew Ruby if available, fall back to system Ruby
if command -v brew >/dev/null 2>&1; then
  brew_ruby="$(brew --prefix ruby 2>/dev/null)/bin/ruby"
  if [ -x "$brew_ruby" ]; then
    exec "$brew_ruby" -x "$0" "$@"
  fi
fi
exec ruby -x "$0" "$@"

#!ruby
# frozen_string_literal: true

# Generic dev runner: find repo with dev.yml, enable CLI::UI when TTY, run commands in a Frame.
# Ruby scripts are run in-process so they inherit CLI::UI; non-Ruby runs as subprocess inside the Frame.

require "yaml"

def find_repo_root
  d = Dir.pwd
  while d && d != "/"
    return d if File.file?(File.join(d, "dev.yml"))
    d = File.dirname(d)
  end
  nil
end

def load_dev_yml(root)
  path = File.join(root, "dev.yml")
  YAML.load_file(path) if File.file?(path)
rescue Psych::SyntaxError => e
  $stderr.puts "dev: invalid YAML in #{path}: #{e.message}"
  nil
end

def enable_cli_ui
  return unless $stdout.tty?
  require "cli/ui"
  CLI::UI::StdoutRouter.enable
  CLI::UI.enable_color = $stdout.tty? if CLI::UI.respond_to?(:enable_color=)
rescue LoadError
  # cli-ui not installed; run without pretty output
end

def ruby_script?(run_str)
  s = run_str.to_s.strip
  s.end_with?(".rb") && (s.start_with?("./") || s.start_with?("bin/"))
end

def run_command(root, cmd_name, run_str, args)
  run_str = run_str.to_s.strip
  script_path = nil
  if ruby_script?(run_str)
    script_path = File.expand_path(run_str.start_with?("bin/") ? run_str : run_str.sub(/\A\.\//, ""), root)
    script_path = nil unless File.file?(script_path)
  end

  title = cmd_name.to_s.tr("-", " ").split.map(&:capitalize).join(" ")

  if $stdout.tty? && defined?(CLI::UI)
    CLI::UI::Frame.open(title) do
      if script_path
        Dir.chdir(root)
        ARGV.replace(args)
        begin
          load script_path
        rescue SystemExit => e
          exit(e.status || 0)
        end
      else
        exit(1) unless system(run_str, *args)
      end
      puts CLI::UI.fmt("{{green:âœ“}} Done")
    end
  else
    if script_path
      Dir.chdir(root)
      ARGV.replace(args)
      begin
        load script_path
      rescue SystemExit => e
        exit(e.status || 0)
      end
    else
      # Non-Ruby: exec so we don't wrap in a subshell (preserve exit code and signals)
      Dir.chdir(root)
      exec(run_str, *args)
    end
  end
end

def usage(config)
  name = config["name"] || "this repo"
  commands = config["commands"] || {}
  puts "Usage: dev <command> [args...]"
  puts ""
  puts "Commands for #{name}:"
  if commands.empty?
    puts "  (no commands defined in dev.yml)"
  else
    commands.each do |cmd, spec|
      desc = spec.is_a?(Hash) && spec["desc"] ? spec["desc"] : "(no description)"
      puts "  #{cmd.ljust(12)} #{desc}"
    end
  end
  puts ""
  puts "Examples: dev up    dev up -v    dev update-deps    dev test"
end

# Main
root = find_repo_root
unless root
  $stderr.puts "dev: no dev.yml found in current or parent directories"
  exit 1
end

config = load_dev_yml(root)
unless config && config["commands"]
  $stderr.puts "dev: invalid dev.yml or no commands"
  exit 1
end

commands = config["commands"]
args = ARGV.dup

if args.empty? || args == ["--help"] || args == ["-h"]
  usage(config)
  exit 0
end

cmd_name = args.shift
spec = commands[cmd_name]
unless spec.is_a?(Hash) && spec["run"]
  $stderr.puts "dev: unknown command #{cmd_name}"
  $stderr.puts "Run 'dev' or 'dev --help' to see available commands."
  exit 1
end

enable_cli_ui
run_command(root, cmd_name, spec["run"], args)
