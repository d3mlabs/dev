# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `ast_transform` gem.
# Please instead update this file by running `bin/tapioca gem ast_transform`.

module ASTTransform
  class << self
    def acronym(acronym); end
    def acronyms; end
    def install; end
    def output_path; end
    def output_path=(path); end
  end
end

class ASTTransform::AbstractTransformation < ::Parser::AST::Processor
  include ::ASTTransform::TransformationHelper
  include ::ASTTransform::TransformationHelper::Methods
  extend ::ASTTransform::TransformationHelper::Methods

  def process(node); end
  def run(node); end

  private

  def process_node(node); end
end

ASTTransform::DEFAULT_OUTPUT_PATH = T.let(T.unsafe(nil), String)

module ASTTransform::InstructionSequence
  class << self
    def source_to_transformed_iseq(source, source_path); end
    def using_bootsnap_compilation?; end
    def write(string, pathname); end
    def write_pathname(file_path); end
  end
end

module ASTTransform::InstructionSequence::BootsnapMixin
  def input_to_storage(source, source_path); end
end

module ASTTransform::InstructionSequence::Mixin
  def load_iseq(source_path); end
end

module ASTTransform::MixinUtils
  class << self
    def try_super(target, method_sym, *args, &block); end
  end
end

class ASTTransform::SourceMap
  def initialize(source_file_path, transformed_file_path, source_ranges_ast, transformed_ranges_ast); end

  def line(line_number); end
  def line_count; end
  def source_file_path; end
  def source_map; end
  def transformed_file_path; end

  private

  def approximate_dig_last_valid_node(node, indexes, depth = T.unsafe(nil)); end
  def build_source_map; end
  def dig_last_valid_node(node, indexes); end
  def dig_last_valid_node_index(node, indexes); end
  def dig_node(node, indexes); end
  def extract_source_map_data(node, indexes); end
  def search_node(node, queried_node); end
  def search_range(node, max_range = T.unsafe(nil)); end
  def source_line(line_number); end

  class << self
    def for_file_path(file_path); end
    def register_source_map(source_map); end

    private

    def source_maps; end
  end
end

class ASTTransform::Transformation < ::ASTTransform::AbstractTransformation
  private

  def extract_transformation(node); end
  def extract_transformations(node); end
  def next_child(node, index); end
  def previous_child(node, index); end
  def process_node(node); end
  def process_node_helper(node, previous_node); end
  def require_path(const_name); end
  def require_transformation(node); end
  def transform_node?(node); end
  def transformable_node?(node); end
  def try_const_get(const_name); end
end

ASTTransform::Transformation::TRANSFORM_AST = T.let(T.unsafe(nil), Parser::AST::Node)

module ASTTransform::TransformationHelper
  include ::ASTTransform::TransformationHelper::Methods

  mixes_in_class_methods ::ASTTransform::TransformationHelper::Methods

  class << self
    def included(base); end
  end
end

module ASTTransform::TransformationHelper::Methods
  def s(type, *children, **properties); end
end

class ASTTransform::Transformer
  def initialize(*transformations, builder: T.unsafe(nil)); end

  def build_ast(source, file_path: T.unsafe(nil)); end
  def build_ast_from_file(file_path); end
  def transform(source); end
  def transform_ast(ast); end
  def transform_file(file_path, transformed_file_path); end
  def transform_file_source(source, file_path, transformed_file_path); end

  private

  def create_buffer(source, file_path); end
  def parser; end
  def register_source_map(source_file_path, transformed_file_path, transformed_ast, transformed_source); end
end

ASTTransform::VERSION = T.let(T.unsafe(nil), String)
