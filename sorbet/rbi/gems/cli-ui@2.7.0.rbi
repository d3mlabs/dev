# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `cli-ui` gem.
# Please instead update this file by running `bin/tapioca gem cli-ui`.

module CLI; end

module CLI::UI
  class << self
    def any_key(prompt = T.unsafe(nil)); end
    def ask(question, options: T.unsafe(nil), default: T.unsafe(nil), is_file: T.unsafe(nil), allow_empty: T.unsafe(nil), multiple: T.unsafe(nil), filter_ui: T.unsafe(nil), select_ui: T.unsafe(nil), &options_proc); end
    def confirm(question, default: T.unsafe(nil)); end
    def enable_color=(bool); end
    def enable_color?; end
    def enable_cursor=(bool); end
    def enable_cursor?; end
    def fmt(input, enable_color: T.unsafe(nil)); end
    def frame(text, color: T.unsafe(nil), failure_text: T.unsafe(nil), success_text: T.unsafe(nil), timing: T.unsafe(nil), frame_style: T.unsafe(nil), to: T.unsafe(nil), &block); end
    def frame_style=(frame_style); end
    def glyph(handle); end
    def link(url, text, format: T.unsafe(nil), blue_underline: T.unsafe(nil)); end
    def log_output_to(path, &block); end
    def puts(msg, frame_color: T.unsafe(nil), to: T.unsafe(nil), encoding: T.unsafe(nil), format: T.unsafe(nil), graceful: T.unsafe(nil), wrap: T.unsafe(nil)); end
    def raw(&block); end
    def resolve_color(input); end
    def resolve_style(input); end
    def resolve_text(input, truncate_to: T.unsafe(nil), enable_color: T.unsafe(nil)); end
    def spinner(title, auto_debrief: T.unsafe(nil), to: T.unsafe(nil), &block); end
    def with_frame_color(color, &block); end
    def wrap(input); end
  end
end

module CLI::UI::ANSI
  class << self
    def clear_to_end_of_line; end
    def control(args, cmd); end
    def cursor_back(n = T.unsafe(nil)); end
    def cursor_down(n = T.unsafe(nil)); end
    def cursor_forward(n = T.unsafe(nil)); end
    def cursor_horizontal_absolute(n = T.unsafe(nil)); end
    def cursor_restore; end
    def cursor_save; end
    def cursor_up(n = T.unsafe(nil)); end
    def enter_alternate_screen; end
    def exit_alternate_screen; end
    def hide_cursor; end
    def insert_line; end
    def insert_lines(n = T.unsafe(nil)); end
    def match_alternate_screen; end
    def next_line; end
    def previous_line; end
    def previous_lines(n = T.unsafe(nil)); end
    def printing_width(str); end
    def sgr(params); end
    def show_cursor; end
    def strip_codes(str); end
  end
end

CLI::UI::ANSI::CSI_SEQUENCE = T.let(T.unsafe(nil), Regexp)
CLI::UI::ANSI::ESC = T.let(T.unsafe(nil), String)
CLI::UI::ANSI::OSC_SEQUENCE = T.let(T.unsafe(nil), Regexp)

class CLI::UI::Color
  def initialize(sgr, name); end

  def code; end
  def name; end
  def sgr; end

  class << self
    def available; end
    def lookup(name); end
  end
end

CLI::UI::Color::BLUE = T.let(T.unsafe(nil), CLI::UI::Color)
CLI::UI::Color::BOLD = T.let(T.unsafe(nil), CLI::UI::Color)
CLI::UI::Color::CYAN = T.let(T.unsafe(nil), CLI::UI::Color)
CLI::UI::Color::GRAY = T.let(T.unsafe(nil), CLI::UI::Color)
CLI::UI::Color::GREEN = T.let(T.unsafe(nil), CLI::UI::Color)

class CLI::UI::Color::InvalidColorName < ::ArgumentError
  def initialize(name); end

  def message; end
end

CLI::UI::Color::MAGENTA = T.let(T.unsafe(nil), CLI::UI::Color)
CLI::UI::Color::MAP = T.let(T.unsafe(nil), Hash)
CLI::UI::Color::ORANGE = T.let(T.unsafe(nil), CLI::UI::Color)
CLI::UI::Color::RED = T.let(T.unsafe(nil), CLI::UI::Color)
CLI::UI::Color::RESET = T.let(T.unsafe(nil), CLI::UI::Color)
CLI::UI::Color::WHITE = T.let(T.unsafe(nil), CLI::UI::Color)
CLI::UI::Color::YELLOW = T.let(T.unsafe(nil), CLI::UI::Color)

class CLI::UI::Formatter
  def initialize(text); end

  def format(sgr_map = T.unsafe(nil), enable_color: T.unsafe(nil)); end

  private

  def apply_format(text, fmt, sgr_map); end
  def emit(text, stack); end
  def parse_body(sc, stack = T.unsafe(nil)); end
  def parse_expr(sc, stack); end
end

CLI::UI::Formatter::BEGIN_EXPR = T.let(T.unsafe(nil), String)
CLI::UI::Formatter::DISCARD_BRACES = T.let(T.unsafe(nil), Range)
CLI::UI::Formatter::END_EXPR = T.let(T.unsafe(nil), String)

class CLI::UI::Formatter::FormatError < ::StandardError
  def initialize(message, input, index); end

  def index; end
  def index=(_arg0); end
  def input; end
  def input=(_arg0); end
end

class CLI::UI::Formatter::LITERAL_BRACES; end
CLI::UI::Formatter::SCAN_BODY = T.let(T.unsafe(nil), Regexp)
CLI::UI::Formatter::SCAN_FUNCNAME = T.let(T.unsafe(nil), Regexp)
CLI::UI::Formatter::SCAN_GLYPH = T.let(T.unsafe(nil), Regexp)
CLI::UI::Formatter::SCAN_WIDGET = T.let(T.unsafe(nil), Regexp)
CLI::UI::Formatter::SGR_MAP = T.let(T.unsafe(nil), Hash)

module CLI::UI::Frame
  class << self
    def close(text, color: T.unsafe(nil), elapsed: T.unsafe(nil), frame_style: T.unsafe(nil), to: T.unsafe(nil)); end
    def divider(text, color: T.unsafe(nil), frame_style: T.unsafe(nil), to: T.unsafe(nil)); end
    def frame_style; end
    def frame_style=(frame_style); end
    def open(text, color: T.unsafe(nil), failure_text: T.unsafe(nil), success_text: T.unsafe(nil), timing: T.unsafe(nil), frame_style: T.unsafe(nil), to: T.unsafe(nil), &block); end
    def prefix(color: T.unsafe(nil)); end
    def prefix_width; end
    def with_frame_color_override(color, &block); end

    private

    def elapsed(start, timing); end
  end
end

CLI::UI::Frame::DEFAULT_FRAME_COLOR = T.let(T.unsafe(nil), CLI::UI::Color)

module CLI::UI::Frame::FrameStack
  class << self
    def items; end
    def pop; end
    def push(item = T.unsafe(nil), color: T.unsafe(nil), style: T.unsafe(nil)); end
  end
end

class CLI::UI::Frame::FrameStack::StackItem
  def initialize(color_name, style_name); end

  def color; end
  def frame_style; end
end

module CLI::UI::Frame::FrameStyle
  def close(text, color:, right_text: T.unsafe(nil)); end
  def divider(text, color:); end
  def prefix; end
  def prefix_width; end
  def print_at_x(x, str); end
  def start(text, color:); end
  def style_name; end

  class << self
    def lookup(name); end
  end
end

module CLI::UI::Frame::FrameStyle::Box
  extend ::CLI::UI::Frame::FrameStyle

  class << self
    def close(text, color:, right_text: T.unsafe(nil)); end
    def divider(text, color:); end
    def prefix; end
    def start(text, color:); end
    def style_name; end

    private

    def edge(text, color:, first:, right_text: T.unsafe(nil)); end
  end
end

CLI::UI::Frame::FrameStyle::Box::BOTTOM_LEFT = T.let(T.unsafe(nil), String)
CLI::UI::Frame::FrameStyle::Box::DIVIDER = T.let(T.unsafe(nil), String)
CLI::UI::Frame::FrameStyle::Box::HORIZONTAL = T.let(T.unsafe(nil), String)
CLI::UI::Frame::FrameStyle::Box::TOP_LEFT = T.let(T.unsafe(nil), String)
CLI::UI::Frame::FrameStyle::Box::VERTICAL = T.let(T.unsafe(nil), String)

module CLI::UI::Frame::FrameStyle::Bracket
  extend ::CLI::UI::Frame::FrameStyle

  class << self
    def close(text, color:, right_text: T.unsafe(nil)); end
    def divider(text, color:); end
    def prefix; end
    def start(text, color:); end
    def style_name; end

    private

    def edge(text, color:, first:, right_text: T.unsafe(nil)); end
  end
end

CLI::UI::Frame::FrameStyle::Bracket::BOTTOM_LEFT = T.let(T.unsafe(nil), String)
CLI::UI::Frame::FrameStyle::Bracket::DIVIDER = T.let(T.unsafe(nil), String)
CLI::UI::Frame::FrameStyle::Bracket::HORIZONTAL = T.let(T.unsafe(nil), String)
CLI::UI::Frame::FrameStyle::Bracket::TOP_LEFT = T.let(T.unsafe(nil), String)
CLI::UI::Frame::FrameStyle::Bracket::VERTICAL = T.let(T.unsafe(nil), String)

class CLI::UI::Frame::FrameStyle::InvalidFrameStyleName < ::ArgumentError
  def initialize(name); end

  def message; end
end

CLI::UI::Frame::FrameStyle::MAP = T.let(T.unsafe(nil), Hash)
class CLI::UI::Frame::UnnestedFrameException < ::StandardError; end

class CLI::UI::Glyph
  def initialize(handle, codepoint, plain, color); end

  def char; end
  def codepoint; end
  def color; end
  def fmt; end
  def handle; end
  def to_s; end

  class << self
    def available; end
    def lookup(name); end
  end
end

CLI::UI::Glyph::BUG = T.let(T.unsafe(nil), CLI::UI::Glyph)
CLI::UI::Glyph::CHECK = T.let(T.unsafe(nil), CLI::UI::Glyph)
CLI::UI::Glyph::CHEVRON = T.let(T.unsafe(nil), CLI::UI::Glyph)
CLI::UI::Glyph::HOURGLASS = T.let(T.unsafe(nil), CLI::UI::Glyph)
CLI::UI::Glyph::INFO = T.let(T.unsafe(nil), CLI::UI::Glyph)

class CLI::UI::Glyph::InvalidGlyphHandle < ::ArgumentError
  def initialize(handle); end

  def message; end
end

CLI::UI::Glyph::MAP = T.let(T.unsafe(nil), Hash)
CLI::UI::Glyph::QUESTION = T.let(T.unsafe(nil), CLI::UI::Glyph)
CLI::UI::Glyph::STAR = T.let(T.unsafe(nil), CLI::UI::Glyph)
CLI::UI::Glyph::WARNING = T.let(T.unsafe(nil), CLI::UI::Glyph)
CLI::UI::Glyph::X = T.let(T.unsafe(nil), CLI::UI::Glyph)

class CLI::UI::OS
  def initialize(emoji: T.unsafe(nil), color_prompt: T.unsafe(nil), arrow_keys: T.unsafe(nil), shift_cursor: T.unsafe(nil)); end

  def shift_cursor_back_on_horizontal_absolute?; end
  def suggest_arrow_keys?; end
  def use_color_prompt?; end
  def use_emoji?; end

  class << self
    def current; end
  end
end

CLI::UI::OS::FREEBSD = T.let(T.unsafe(nil), CLI::UI::OS)
CLI::UI::OS::LINUX = T.let(T.unsafe(nil), CLI::UI::OS)
CLI::UI::OS::MAC = T.let(T.unsafe(nil), CLI::UI::OS)
CLI::UI::OS::WINDOWS = T.let(T.unsafe(nil), CLI::UI::OS)

class CLI::UI::Printer
  class << self
    def puts(msg, frame_color: T.unsafe(nil), to: T.unsafe(nil), encoding: T.unsafe(nil), format: T.unsafe(nil), graceful: T.unsafe(nil), wrap: T.unsafe(nil)); end
  end
end

class CLI::UI::Progress
  def initialize(title = T.unsafe(nil), width: T.unsafe(nil), reporter: T.unsafe(nil)); end

  def tick(percent: T.unsafe(nil), set_percent: T.unsafe(nil)); end
  def to_s; end
  def update_title(new_title); end

  class << self
    def progress(title = T.unsafe(nil), width: T.unsafe(nil), &block); end
  end
end

CLI::UI::Progress::FILLED_BAR = T.let(T.unsafe(nil), String)
CLI::UI::Progress::UNFILLED_BAR = T.let(T.unsafe(nil), String)

module CLI::UI::ProgressReporter
  class << self
    def current_reporter; end
    def reporter_stack; end
    def supports_progress?; end
    def with_progress(mode: T.unsafe(nil), to: T.unsafe(nil), delay_start: T.unsafe(nil), &block); end
  end
end

class CLI::UI::ProgressReporter::Reporter
  def initialize(mode, to = T.unsafe(nil), parent: T.unsafe(nil), delay_start: T.unsafe(nil)); end

  def add_child(child); end
  def cleanup; end
  def clear; end
  def force_set_indeterminate; end
  def force_set_progress(percentage); end
  def has_active_children?; end
  def remove_child(child); end
  def set_error; end
  def set_indeterminate; end
  def set_paused(percentage = T.unsafe(nil)); end
  def set_progress(percentage); end
end

CLI::UI::ProgressReporter::Reporter::ERROR = T.let(T.unsafe(nil), Integer)
CLI::UI::ProgressReporter::Reporter::INDETERMINATE = T.let(T.unsafe(nil), Integer)
CLI::UI::ProgressReporter::Reporter::OSC = T.let(T.unsafe(nil), String)
CLI::UI::ProgressReporter::Reporter::PAUSED = T.let(T.unsafe(nil), Integer)
CLI::UI::ProgressReporter::Reporter::REMOVE = T.let(T.unsafe(nil), Integer)
CLI::UI::ProgressReporter::Reporter::SET_PROGRESS = T.let(T.unsafe(nil), Integer)
CLI::UI::ProgressReporter::Reporter::ST = T.let(T.unsafe(nil), String)

module CLI::UI::Prompt
  class << self
    def any_key(prompt = T.unsafe(nil)); end
    def ask(question, options: T.unsafe(nil), default: T.unsafe(nil), is_file: T.unsafe(nil), allow_empty: T.unsafe(nil), multiple: T.unsafe(nil), filter_ui: T.unsafe(nil), select_ui: T.unsafe(nil), &options_proc); end
    def ask_password(question); end
    def confirm(question, default: T.unsafe(nil)); end
    def instructions_color; end
    def instructions_color=(color); end
    def read_char; end

    private

    def ask_free_form(question, default, is_file, allow_empty); end
    def ask_interactive(question, options = T.unsafe(nil), multiple: T.unsafe(nil), default: T.unsafe(nil), filter_ui: T.unsafe(nil), select_ui: T.unsafe(nil)); end
    def interactive_prompt(options, multiple: T.unsafe(nil), default: T.unsafe(nil)); end
    def puts_question(str); end
    def readline(is_file: T.unsafe(nil)); end
    def write_default_over_empty_input(default); end
  end
end

class CLI::UI::Prompt::InteractiveOptions
  def initialize(options, multiple: T.unsafe(nil), default: T.unsafe(nil)); end

  def call; end

  private

  def build_selection(char); end
  def calculate_option_line_lengths; end
  def chop_selection; end
  def clear_output(number_of_lines = T.unsafe(nil)); end
  def display_metadata?; end
  def distance_from_selection_to_end; end
  def distance_from_start_to_selection; end
  def down; end
  def ensure_first_item_is_continuation_marker; end
  def ensure_last_item_is_continuation_marker; end
  def ensure_visible_is_active; end
  def filtering?; end
  def first_option; end
  def format_choice(format, choice); end
  def has_filter?; end
  def index_of_active_option; end
  def last_option; end
  def max_lines; end
  def next_page; end
  def num_lines; end
  def presented_options(recalculate: T.unsafe(nil)); end
  def previous_page; end
  def process_input_until_redraw_required; end
  def render_options; end
  def reset_position(number_of_lines = T.unsafe(nil)); end
  def select_bool(char); end
  def select_current; end
  def select_n(n, final: T.unsafe(nil)); end
  def selecting?; end
  def should_enter_select_mode?(n); end
  def start_filter; end
  def start_line_select; end
  def stop_line_select; end
  def terminal_width_changed?; end
  def up; end
  def update_search(char); end
  def wait_for_user_input; end

  class << self
    def call(options, multiple: T.unsafe(nil), default: T.unsafe(nil)); end
  end
end

CLI::UI::Prompt::InteractiveOptions::BACKSPACE = T.let(T.unsafe(nil), String)
CLI::UI::Prompt::InteractiveOptions::CHECKBOX_ICON = T.let(T.unsafe(nil), Hash)
CLI::UI::Prompt::InteractiveOptions::CTRL_C = T.let(T.unsafe(nil), String)
CLI::UI::Prompt::InteractiveOptions::CTRL_D = T.let(T.unsafe(nil), String)
CLI::UI::Prompt::InteractiveOptions::DONE = T.let(T.unsafe(nil), String)
CLI::UI::Prompt::InteractiveOptions::ESC = T.let(T.unsafe(nil), String)

class CLI::UI::Prompt::OptionsHandler
  def initialize; end

  def call(options); end
  def option(option, &handler); end
  def options; end
end

class CLI::UI::ReentrantMutex < ::Thread::Mutex
  def initialize; end

  def count; end
  def lock; end
  def synchronize; end
  def unlock; end

  private

  def decrease_count(thread); end
  def delete_count(thread); end
  def increase_count(thread); end
end

CLI::UI::SpinGroup = CLI::UI::Spinner::SpinGroup

module CLI::UI::Spinner
  class << self
    def current_rune; end
    def index; end
    def index=(_arg0); end
    def spin(title, auto_debrief: T.unsafe(nil), to: T.unsafe(nil), &block); end
  end
end

class CLI::UI::Spinner::Async
  def initialize(title); end

  def stop; end

  class << self
    def start(title); end
  end
end

CLI::UI::Spinner::GLYPHS = T.let(T.unsafe(nil), Array)
CLI::UI::Spinner::PERIOD = T.let(T.unsafe(nil), Float)
CLI::UI::Spinner::RUNES = T.let(T.unsafe(nil), Array)

class CLI::UI::Spinner::SpinGroup
  def initialize(auto_debrief: T.unsafe(nil), interrupt_debrief: T.unsafe(nil), max_concurrent: T.unsafe(nil), work_queue: T.unsafe(nil), to: T.unsafe(nil)); end

  def add(title, final_glyph: T.unsafe(nil), merged_output: T.unsafe(nil), duplicate_output_to: T.unsafe(nil), &block); end
  def all_succeeded?; end
  def failure_debrief(&block); end
  def puts_above(message); end
  def stop; end
  def stopped?; end
  def success_debrief(&block); end
  def wait(to: T.unsafe(nil)); end

  private

  def debrief(to: T.unsafe(nil)); end
  def render_puts_above(to, consumed_lines); end
  def render_tasks(to:, tasks_seen:, tasks_seen_done:, consumed_lines:, idx:, force_full_render:, width:); end
  def update_progress_mode(reporter, current_mode, first_render); end

  class << self
    def pause_mutex; end
    def pause_spinners(&block); end
    def paused?; end
  end
end

CLI::UI::Spinner::SpinGroup::DEFAULT_FINAL_GLYPH = T.let(T.unsafe(nil), Proc)

class CLI::UI::Spinner::SpinGroup::Task
  def initialize(title, final_glyph:, merged_output:, duplicate_output_to:, work_queue:, &block); end

  def check; end
  def clear_progress; end
  def current_progress; end
  def done; end
  def exception; end
  def on_done(&block); end
  def progress_percentage; end
  def render(index, force = T.unsafe(nil), width: T.unsafe(nil)); end
  def set_progress(percentage); end
  def stderr; end
  def stdout; end
  def success; end
  def title; end
  def update_title(new_title); end
  def wants_progress_mode?; end

  private

  def full_render(index, terminal_width); end
  def glyph(index); end
  def inset; end
  def inset_width; end
  def partial_render(index); end
end

CLI::UI::Spinner::TASK_FAILED = T.let(T.unsafe(nil), Symbol)

module CLI::UI::StdoutRouter
  class << self
    def assert_enabled!; end
    def current_id; end
    def disable; end
    def duplicate_output_to; end
    def duplicate_output_to=(_arg0); end
    def enable; end
    def enabled?(stream = T.unsafe(nil)); end
    def ensure_activated; end
    def with_enabled(&block); end
    def with_id(on_streams:, &block); end

    private

    def activate(stream, streamname); end
    def deactivate(stream); end
  end
end

class CLI::UI::StdoutRouter::Capture
  def initialize(with_frame_inset: T.unsafe(nil), merged_output: T.unsafe(nil), duplicate_output_to: T.unsafe(nil), &block); end

  def print_captured_output; end
  def print_captured_output=(_arg0); end
  def run; end
  def stderr; end
  def stdout; end

  class << self
    def current_capture; end
    def current_capture!; end
    def in_alternate_screen(&block); end
    def stdin_synchronize(&block); end
    def with_stdin_masked(&block); end

    private

    def outermost_uncaptured?; end
  end
end

class CLI::UI::StdoutRouter::Capture::BlockingInput
  def initialize(stream); end

  def <<(*args, **kwargs, &block); end
  def advise(*args, **kwargs, &block); end
  def autoclose=(*args, **kwargs, &block); end
  def autoclose?(*args, **kwargs, &block); end
  def binmode(*args, **kwargs, &block); end
  def binmode?(*args, **kwargs, &block); end
  def bytes(*args, **kwargs, &block); end
  def chars(*args, **kwargs, &block); end
  def close(*args, **kwargs, &block); end
  def close_on_exec=(*args, **kwargs, &block); end
  def close_on_exec?(*args, **kwargs, &block); end
  def close_read(*args, **kwargs, &block); end
  def close_write(*args, **kwargs, &block); end
  def closed?(*args, **kwargs, &block); end
  def codepoints(*args, **kwargs, &block); end
  def each(*args, **kwargs, &block); end
  def each_byte(*args, **kwargs, &block); end
  def each_char(*args, **kwargs, &block); end
  def each_codepoint(*args, **kwargs, &block); end
  def each_line(*args, **kwargs, &block); end
  def eof(*args, **kwargs, &block); end
  def eof?(*args, **kwargs, &block); end
  def external_encoding(*args, **kwargs, &block); end
  def fcntl(*args, **kwargs, &block); end
  def fdatasync(*args, **kwargs, &block); end
  def fileno(*args, **kwargs, &block); end
  def flush(*args, **kwargs, &block); end
  def fsync(*args, **kwargs, &block); end
  def getbyte(*args, **kwargs, &block); end
  def getc(*args, **kwargs, &block); end
  def getch(*args, **kwargs, &block); end
  def gets(*args, **kwargs, &block); end
  def inspect(*args, **kwargs, &block); end
  def internal_encoding(*args, **kwargs, &block); end
  def ioctl(*args, **kwargs, &block); end
  def isatty(*args, **kwargs, &block); end
  def lineno(*args, **kwargs, &block); end
  def lineno=(*args, **kwargs, &block); end
  def lines(*args, **kwargs, &block); end
  def pathconf(*args, **kwargs, &block); end
  def pid(*args, **kwargs, &block); end
  def pos(*args, **kwargs, &block); end
  def pos=(*args, **kwargs, &block); end
  def pread(*args, **kwargs, &block); end
  def print(*args, **kwargs, &block); end
  def printf(*args, **kwargs, &block); end
  def putc(*args, **kwargs, &block); end
  def puts(*args, **kwargs, &block); end
  def pwrite(*args, **kwargs, &block); end
  def read(*args, **kwargs, &block); end
  def read_nonblock(*args, **kwargs, &block); end
  def readbyte(*args, **kwargs, &block); end
  def readchar(*args, **kwargs, &block); end
  def readline(*args, **kwargs, &block); end
  def readlines(*args, **kwargs, &block); end
  def readpartial(*args, **kwargs, &block); end
  def reopen(*args, **kwargs, &block); end
  def rewind(*args, **kwargs, &block); end
  def seek(*args, **kwargs, &block); end
  def set_encoding(*args, **kwargs, &block); end
  def set_encoding_by_bom(*args, **kwargs, &block); end
  def stat(*args, **kwargs, &block); end
  def sync(*args, **kwargs, &block); end
  def sync=(*args, **kwargs, &block); end
  def synchronize(&block); end
  def sysread(*args, **kwargs, &block); end
  def sysseek(*args, **kwargs, &block); end
  def syswrite(*args, **kwargs, &block); end
  def tell(*args, **kwargs, &block); end
  def to_i(*args, **kwargs, &block); end
  def to_io(*args, **kwargs, &block); end
  def tty?(*args, **kwargs, &block); end
  def ungetbyte(*args, **kwargs, &block); end
  def ungetc(*args, **kwargs, &block); end
  def write(*args, **kwargs, &block); end
  def write_nonblock(*args, **kwargs, &block); end
end

CLI::UI::StdoutRouter::Capture::BlockingInput::NON_READING_METHODS = T.let(T.unsafe(nil), Array)
CLI::UI::StdoutRouter::Capture::BlockingInput::READING_METHODS = T.let(T.unsafe(nil), Array)

class CLI::UI::StdoutRouter::Writer
  def initialize(stream, name); end

  def write(*args); end

  private

  def apply_line_prefix(str, prefix); end
  def auto_frame_inset?; end
  def prepend_id(stream, args); end
  def prepend_id_for_stream(stream); end
end

module CLI::UI::Table
  class << self
    def capture_table(table, col_spacing: T.unsafe(nil)); end
    def puts_table(table, col_spacing: T.unsafe(nil), to: T.unsafe(nil)); end
  end
end

module CLI::UI::Terminal
  class << self
    def height; end
    def setup_winsize_trap; end
    def width; end
    def winsize; end
  end
end

CLI::UI::Terminal::DEFAULT_HEIGHT = T.let(T.unsafe(nil), Integer)
CLI::UI::Terminal::DEFAULT_WIDTH = T.let(T.unsafe(nil), Integer)

module CLI::UI::Truncater
  class << self
    def call(text, printing_width); end

    private

    def width(printable_codepoint); end
  end
end

CLI::UI::Truncater::EMOJI_RANGE = T.let(T.unsafe(nil), Range)
CLI::UI::Truncater::ESC = T.let(T.unsafe(nil), Integer)
CLI::UI::Truncater::LC_ALPHA_RANGE = T.let(T.unsafe(nil), Range)
CLI::UI::Truncater::LEFT_SQUARE_BRACKET = T.let(T.unsafe(nil), Integer)
CLI::UI::Truncater::NUMERIC_RANGE = T.let(T.unsafe(nil), Range)
CLI::UI::Truncater::PARSE_ANSI = T.let(T.unsafe(nil), Symbol)
CLI::UI::Truncater::PARSE_ESC = T.let(T.unsafe(nil), Symbol)
CLI::UI::Truncater::PARSE_ROOT = T.let(T.unsafe(nil), Symbol)
CLI::UI::Truncater::PARSE_ZWJ = T.let(T.unsafe(nil), Symbol)
CLI::UI::Truncater::SEMICOLON = T.let(T.unsafe(nil), Integer)
CLI::UI::Truncater::TRUNCATED = T.let(T.unsafe(nil), String)
CLI::UI::Truncater::UC_ALPHA_RANGE = T.let(T.unsafe(nil), Range)
CLI::UI::Truncater::ZWJ = T.let(T.unsafe(nil), Integer)

module CLI::UI::Widgets
  class << self
    def available; end
    def lookup(handle); end
    def register(name, &cb); end
  end
end

class CLI::UI::Widgets::Base
  def initialize(argstring); end

  def render; end

  class << self
    def argparse_pattern; end
    def call(argstring); end
  end
end

class CLI::UI::Widgets::InvalidWidgetArguments < ::ArgumentError
  def initialize(argstring, pattern); end

  def message; end
end

class CLI::UI::Widgets::InvalidWidgetHandle < ::ArgumentError
  def initialize(handle); end

  def message; end
end

CLI::UI::Widgets::MAP = T.let(T.unsafe(nil), Hash)

class CLI::UI::Widgets::Status < ::CLI::UI::Widgets::Base
  def render; end

  private

  def colorize_if_nonzero(num_str, rune, color); end
  def failed_part; end
  def pending_part; end
  def succeeded_part; end
  def working_part; end
  def zero?(num_str); end

  class << self
    def argparse_pattern; end
  end
end

CLI::UI::Widgets::Status::ARGPARSE_PATTERN = T.let(T.unsafe(nil), Regexp)
CLI::UI::Widgets::Status::ARROW = T.let(T.unsafe(nil), String)
CLI::UI::Widgets::Status::CLOSE = T.let(T.unsafe(nil), String)
CLI::UI::Widgets::Status::COMMA = T.let(T.unsafe(nil), String)
CLI::UI::Widgets::Status::EMPTY_SET = T.let(T.unsafe(nil), String)
CLI::UI::Widgets::Status::OPEN = T.let(T.unsafe(nil), String)
CLI::UI::Widgets::Status::SPINNER_STOPPED = T.let(T.unsafe(nil), String)

class CLI::UI::WorkQueue
  def initialize(max_concurrent); end

  def close; end
  def enqueue(&block); end
  def interrupt; end
  def wait; end

  private

  def start_worker; end
end

class CLI::UI::WorkQueue::Future
  def initialize; end

  def complete(result); end
  def completed?; end
  def fail(error); end
  def start; end
  def started?; end
  def value; end
end

class CLI::UI::Wrap
  def initialize(input); end

  def wrap(total_width = T.unsafe(nil)); end
end
